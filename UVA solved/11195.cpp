#include <cstdio>
#include <cassert>
#include <climits>
#include <cstdlib>
#include <cstring>
#include <cctype>
#include <cmath>
#include <ctime>
#include <iostream>
#include <sstream>
#include <iomanip>
#include <string>
#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <deque>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>

#define FOR(i, a, b) for (i = (a); i <= (b); i++)
#define REP(i, a) for (i = 0; i < (a); i++)
#define ALL(v) (v).begin(), (v).end()
#define SET(a, x) memset((a), (x), sizeof(a))
#define SZ(a) ((int)(a).size())
#define CL(a) ((a).clear())
#define SORT(x) sort(ALL(x))
#define mp make_pair
#define pb push_back
#define MAX(a,b) ((a)>(b)?(a):(b))
#define MIN(a,b) ((a)<(b)?(a):(b))

#define filer() freopen("in.txt","r",stdin)
#define filew() freopen("out.txt","w",stdout)

using namespace std;

typedef long long ll;
typedef unsigned long long llu;

int input[12][15];
vector<int> inputWithSize[15];
int n, ks = 1, R;
int pwr[16], conf[15];
int result[15];
int conflict[15][15];
char xdir[] = {1, 1};
char ydir[] = {1, -1};
int total;

struct Node{
	int val;
	Node *next, *prev;
};

Node *head, *tail;
Node *newNode(int n){
	Node *ptr = (Node*)malloc(sizeof(Node));
	ptr->val = n;
	ptr->prev = ptr->next = 0;
	
	return ptr;
}

void reInsert(Node *ptr){
	ptr->prev->next = ptr;
	ptr->next->prev = ptr;
}

void insert(Node *prev, Node *ptr){
	ptr->next = prev->next;
	prev->next = ptr;
	ptr->prev = prev;
	if ( ptr->next ) ptr->next->prev = ptr;
}

Node* remove(Node *ptr){
	ptr->next->prev = ptr->prev;
	ptr->prev->next = ptr->next;
	
	return ptr;
}

void relax(int row, int col, int val){
	int u, v;
	
	for ( int i = 0 ; i < 2 ; i++ ){
		u = row, v = col;
		for ( int j = row + 1 ; j < R ; j++ ){
			u += xdir[i], v += ydir[i];
			if ( u >= 0 && u < R && v >= 0 && v < R ) conflict[u][v] += val;
		}
	}
}

void backTrack(int row){
	if ( row == R ){
		total++;
		for ( int i = 0 ; i < inputWithSize[R].size() ; i++ ){
			int j = 0;
			int ind = inputWithSize[R][i];
			for ( ; j < R ; j++ ){
				if ( conf[j] & input[ind][j] ) break;
			}
			
			if ( j == R ) result[ind]++;
		}
		
		return;
	}
	
	for ( Node* ptr = head->next ; ptr != tail ; ptr = ptr->next ){
		int col = ptr->val;
		if ( col >= R ) break;
		if ( conflict[row][col] == 0 ){
			conf[row] |= pwr[col];
			ptr = remove(ptr);
			// relax
			relax(row, col, 1);
			
			backTrack(row + 1);
			
			reInsert(ptr);
			// relax again
			conf[row] ^= pwr[col];
			relax(row, col, -1);
		}
	}
}

int main(){
	char grid[15][15];
	
	head = newNode(-1);
	tail = newNode(-1);
	insert(head, tail);
	
	pwr[0] = 1;
	for ( int i = 1 ; i <= 15 ; i++ ){
		pwr[i] = pwr[i-1] << 1;
	}
	
	for ( int i = 15 ; i >= 0 ; i-- ) insert(head, newNode(i));
	
	while ( scanf("%d", &n) == 1 && n ){
		for ( int i = 0 ; i < n; i++ ){
			scanf("%s", grid[i]);
			int musk = 0;
			for ( int j = 0 ; j < n ; j++ )
				if ( grid[i][j] == '*' ) musk |= pwr[j];

			input[ks][i] = musk;
		}
		
		inputWithSize[n].pb(ks);
		ks++;
	}
	
	for ( int i = 0 ; i < 15 ; i++ ){
		total = 0;
		R = i;
		if(inputWithSize[i].size()) backTrack(0);
	}
	
	for ( int i = 1 ; i < ks ; i++ ){
		printf("Case %d: %d\n", i, result[i]);
	}

	do{
		Node *ptr = head;
		head = head->next;
		free(ptr);
	}while ( head );
	
	return 0;
}
/*
4
....
....
....
....
5
.....
.....
.....
.....
.....
6
......
......
......
......
......
......
7
.......
.......
.......
.......
.......
.......
.......
8
........
........
........
........
........
........
........
........
9
.........
.........
.........
.........
.........
.........
.........
.........
.........
10
..........
..........
..........
..........
..........
..........
..........
..........
..........
..........
11
...........
...........
...........
...........
...........
...........
...........
...........
...........
...........
...........
12
............
............
............
............
............
............
............
............
............
............
............
............
14
..............
..............
..............
..............
..............
..............
..............
..............
..............
..............
..............
..............
..............
..............
0
*/
